/*
 * nom         : Serveur
 * 
 * description : cette classe nous permet de faire fonctionner notre serveur
 * 
 * Date        : 31/03/2023
 * 
 * Copyright   : Teinturier, Qaeze
 */

package projet.serveur;

import java.io.*;
import java.net.*;
import java.util.*;

public class Serveur{

    //port
    static final int          port = 8000;
    static       ServerSocket serveur;

    //workers et clients
    static int nbMaxConnectes;
    static int nbWorkers;
    static int nbClients;

    //ArrayLists pour l'affichage
    static ArrayList<ConnexionClient> Liste_Client;
    static ArrayList<ConnexionWorker> Liste_Worker;

    //stockage des données
    static double NumerateurMoyenneTotale;
    static int    nbCalculees;              /*le nombre le plus grand en cours de calcul*/
    static int    nbStockees;               /*nombre de valeurs stockées */
    static int    repartitionOrdre[];       /*tableau qui contient le nombre d'occurences de chaque ordre */
    static String fileNameTab;              /*nom du fichier du tableau */


    public static void main(String[] args){


        //fichier tab.ser
        File f = new File("Serveur.java");
        String filename = f.getAbsolutePath();
        filename = filename.replace("Serveur.java", "");
        File files = new File(filename+"tab.ser");
        int[] tab = new int[12];

        if (!files.exists()) {

            //si le fichier contenant notre tableau des occurences des ordres n'existe pas,
            //on initialise notre serveur à partir d'un tableau vide
            for(int i = 0; i < 12 ; i++){
                tab[i] = 0;
            }
            filename = filename + "tab.ser";
        }  else{

            //sinon, on récupère ce tableau et on initialise notre tableau à partir de lui
            try{
                FileInputStream file = new FileInputStream(filename+"tab.ser");
                ObjectInputStream in = new ObjectInputStream(file);
                tab=(int[]) in.readObject();
                filename = filename+"tab.ser";
                in.close();
                file.close();
            } catch(Exception e){e.printStackTrace();}
        }

        //initialisation de nos attributs
        Liste_Client = new ArrayList<ConnexionClient>();
        Liste_Worker = new ArrayList<ConnexionWorker>();
        nbMaxConnectes = 4;
        nbWorkers = 0;
        nbClients = 0;
        NumerateurMoyenneTotale = 0;
        repartitionOrdre = tab;
        for(int i = 0; i < 12; i++){
            nbStockees += repartitionOrdre[i];
            NumerateurMoyenneTotale += i * repartitionOrdre[i];
        }
        nbCalculees = nbStockees;
        fileNameTab = filename;

        try{
            //ouverture du serveur
            System.out.println("Ouverture du serveur sur le port 8000");
            serveur = new ServerSocket(port);

            while(true){
                //s'il y a moins de clients et de workers que le nombre maximal de connections autorisé, on accepte la connexion
                //et on crée le thread correspondant en fonction du message d'identification
                if(nbWorkers + nbClients <= nbMaxConnectes){
                    Socket s = serveur.accept();

                    //on récupère un message pour savoir si la connexion provient d'u client ou d'un worker
                    BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));
                    String identification = reader.readLine();
                    
                    
                    //si la connexion provient d'un client, on créé un thread pour communiquer entre le serveur et le client
                    if(identification.equals("Client")){
                        ConnexionClient cc = new ConnexionClient(s, reader);  
                        Liste_Client.add(cc);
                        cc.start();
                        nbClients++;
                    }

                    //si c'est un worker, on créé un thread pour communiquer entre le serveur et le worker
                    if(identification.equals("Worker")){
                        ConnexionWorker cc = new ConnexionWorker(s, reader);  
                        Liste_Worker.add(cc);
                        cc.start();
                        nbWorkers++;
                    }
                }
            }
        }
        catch(IOException e){e.printStackTrace();}

        try{
            serveur.close();
        }catch(IOException e){e.printStackTrace();}
    }

    /*
     * méthode pour l'affichage
     */
    public static synchronized void Affichage(){

        //Saut de ligne
        System.out.print("\033[H\033[2J");
        System.out.flush();  

        //Création d'une Liste de string qui stocke les lignes à afficher pour les workers
        ArrayList<String> Aff_Client = new ArrayList<String>();
        int m = Liste_Client.size();
        for(int i=0; i<m; i++){
            Aff_Client.addAll(Liste_Client.get(i).getStr());
            Aff_Client.add("                                    ");
            Aff_Client.add("************************************");
            Aff_Client.add("                                    ");
        }

        //Création d'une Liste de string qui stocke les lignes à afficher pour les workers
        ArrayList<String> Aff_Worker = new ArrayList<String>();
        int n = Liste_Worker.size();
        for(int i=0; i<n; i++){
            Aff_Worker.addAll(Liste_Worker.get(i).getStr());
            Aff_Worker.add("                                    ");
            Aff_Worker.add("************************************");
            Aff_Worker.add("                                    ");
        }

        //Affichage final
        int ind = 0;
        int tw = Aff_Worker.size();
        int tc = Aff_Client.size();
        System.out.println("################################# SERVEUR #################################");
        System.out.println("            WORKER                                       CLIENT            ");
        System.out.println("***************************************************************************");
        while(ind<tw || ind<tc){
            
            String sW;
            String sC;

            if(ind<tw){
                sW = Aff_Worker.get(ind);
            }
            else{
                sW = "                                    ";
            }

            if(ind<tc){
                sC = Aff_Client.get(ind);
            }
            else{
                sC = "                                    ";
            }

            System.out.println(sW+" | "+sC);
            ind++;
        }
        System.out.println("###########################################################################");
        System.out.println("Persistance calculée de 0 à "+(nbStockees-1));
    }


    /*
     * méthode pour déterminer un intervalle
     */
    public static synchronized int Intervalle(){
        int a = nbCalculees;
        nbCalculees += 100000;
        return a;
    }

    /*
     * méthode pour remplir le tableau des nombres d'occurences des ordres
     */
    public static synchronized void StockageTabMoy(int[] tab, double moy){

        //on remplit le tableau
        for(int i = 0; i < 12; i++){
            repartitionOrdre[i] += tab[i];
        }

        //on le met dans le fichier
        try
        {  
            FileOutputStream file = new FileOutputStream(fileNameTab);
            ObjectOutputStream out = new ObjectOutputStream(file);
            out.writeObject(repartitionOrdre);
            out.close();
            file.close();
        }catch(IOException ex){ex.printStackTrace();}

        //on incrémente le numérateur de la moyenne
        NumerateurMoyenneTotale+=moy;
        //on incrémente le nombre de valeurs stockées
        nbStockees+=100000;

    }

    /*
     * accesseur en lecture de nbStockees
     */
    public static int getNbStockees(){
        return nbStockees;
    }

    /*
     * méthode qui retourne le pourcentage des nombres d'ordre de persistance nb par rapport au nombre de valeurs stockées
     */
    public static synchronized double pourcentage(int nb){
        double r = (double)(repartitionOrdre[nb])/(double)(nbStockees)*100.0;
        return r;
    }

    public static synchronized double getMoyenneTotale(){
        double m = NumerateurMoyenneTotale/(double) nbStockees;
        return m;
    }

    /*
     * méthodes pour décrémenter le nombre de workers et de clients connectés lorsque l'un d'entre eux se déconnecte
     */
    public static synchronized void FinWorker(){
        nbWorkers--;
    }
    public static synchronized void FinClient(){
        nbClients--;
    }
}
