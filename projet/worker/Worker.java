/*
 * nom         : Worker
 * 
 * description : cette classe nous permet de lancer un worker
 * 
 * Date        : 31/03/2023
 * 
 * Copyright   : Teinturier, Qaeze
 */

package projet.worker;

import java.io.*;
import java.net.*;
import java.util.*;
import projet.echange.*;

public class Worker{

    private static int                  portServeur = 8000;   /*port */
    private static Socket               s;                    /*socket pour la communication*/
    private static BufferedReader       reader;               /*variable pour récupérer les messages du serveur*/
    private static PrintWriter          writer;               /*variable pour envoyer un message au serveur*/
    private static Map<Integer,Integer> HTB;                  /*Map pour stocker les valeurs */
    private static ObjectOutputStream   oos;                  /*variable pour envoyer des objet au serveur */
    private static int                  nbRep;                /*nombre d'intervalles que le worker va gérer */
    private static int[]                repartitionOrdre;     /*tableau du nombre d'occurences de chaque ordres */
    private static double               moy;                  /*numérateur de la moyenne */


    public static void main(String[] args){

        HTB = new HashMap<>();

        // Ouverture du flux entre le Worker et le serveur
        try{

            //Flux entre le Worker et le Serveur
            s = new Socket(args[0],portServeur);

            //initialisation de la connexion au Thread ConnexionWorker
            reader = new BufferedReader(new InputStreamReader(s.getInputStream()));
            writer = new PrintWriter( new BufferedWriter(new OutputStreamWriter(s.getOutputStream())),true);

            //on détermine aléatoirement le nombre d'intervalles que le worker va étudier
            nbRep=(int) (Math.random() * 31 + 20);

            //initialisation de notre tableau
            repartitionOrdre = new int[12];
            for(int i = 0; i < 12; i++){
                repartitionOrdre[i] = 0;
            }

        }catch(IOException e){e.printStackTrace();}
      
        try{
            //identification auprès du serveur
            writer.println("Worker");
            
            //initialisation de la variable oos
            oos = new ObjectOutputStream(s.getOutputStream());

            //envoie du nombre d'intervalles que le worker va gérer
            writer.println(nbRep);

            

            while(nbRep>0){

                //Sert pour la simulation du sleep
                ArrayList<ThreadCalcul> List_Thread = new ArrayList<ThreadCalcul>();

                //on récupère l'intervalle
                int a = Integer.parseInt(reader.readLine());
                int b = Integer.parseInt(reader.readLine());

                //Création du nom que portera le fichier servant au stockage de la Hashatble
                String str = generateurNom(a, b);
                Message tab = new Message();
                tab.setNom(str);

                System.out.println("Calcul [" + a + " , " + b + "]");
                

                //on lance nos threads
                int debI = a;
                int finI = a+19999;
               for(int i = 0; i < 5; i++){
                    ThreadCalcul t = new ThreadCalcul(debI, finI);
                    List_Thread.add(t);
                    t.start();
                    debI = finI + 1;
                    finI += 20000;
               }

               //on vérifies si nos threads ont fini
                int ind = 0;
                int nbThreadsFinis = 0;
                while(nbThreadsFinis < 5){
                    if(List_Thread.get(ind).getTermine()){
                        nbThreadsFinis++;
                    }
                    
                    if(ind == 4 && nbThreadsFinis < 5){
                        ind = 0;
                        nbThreadsFinis = 0;
                    }
                    else{
                        ind++;
                    }
                }

                //préparation de l'objet stockant la Hashtable et le tableau
                Hashtable <Integer, Integer>Liste = new Hashtable<Integer, Integer>(HTB);
                tab.setHTable(Liste);
                tab.setRepartitionOrdre(repartitionOrdre);
                tab.setNumMoy(moy);

                //on réinitialise la map, la moyenne et le tableau
                HTB.clear();
                List_Thread.clear();
                moy = 0;
                repartitionOrdre = new int[12];
                for(int i = 0; i < 12; i++){
                    repartitionOrdre[i] = 0;
                }
                // Envoie de l'objet
                oos.writeObject(tab);

                nbRep--;
            }

        }
        catch(IOException e){e.printStackTrace();}
        try{
            reader.close();
            writer.close();
            oos.close();
            s.close();
        }
        catch(IOException e){e.printStackTrace();}
    }

    /*
     * méthode pour générer un nom de fichier en fonction de l'intervalle
     */
    public static String generateurNom(int a, int b){
        a = a / 100000;
        b = (b + 1) / 100000;
        String str = "" + a + "Cm_" + b + "Cm.ser";
        return str;
    }

    /*
     * méthode pour remplir la hashtable du worker à partir de celle qui est donnée par l'un des threads
     */
    public static synchronized void remplitWorker(Hashtable <Integer, Integer> h, int[] tab, double m){
        HTB.putAll(h);
        moy += m;
        for(int i = 0; i < 12; i++){
            repartitionOrdre[i] += tab[i];
        }
    }
}

