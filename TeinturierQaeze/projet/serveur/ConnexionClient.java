/*
 * nom         : ConnexionClient
 * 
 * description : cette classe gère la communication entre le serveur et un client
 * 
 * Date        : 31/03/2023
 * 
 * Copyright   : Teinturier, Qaeze
 */

package projet.serveur;

import java.io.*;
import java.net.*;
import java.util.*;

public class ConnexionClient extends Thread{

    private BufferedReader reader; /*variable pour récupérer les messages du client */
    private PrintWriter    writer; /*variable pour envoyer un message au client */
    private String         etat;   /*variable pour l'affichage dans la console serveur */
    private Socket         s;      /*socket pour la communication*/ 
   
    public ConnexionClient(Socket s, BufferedReader r){
       try{
            //création des éléments pour la communication entre le client et le serveur
            this.s=s;
            this.reader=r;
            writer = new PrintWriter( new BufferedWriter(new OutputStreamWriter(this.s.getOutputStream())),true);
       }catch(IOException e){e.printStackTrace();}
       }


     public void run(){
        try{
            this.etat = "Connecté";

            //tant que le client est connecté, on répond à ses demandes
            while (true) {
                Serveur.Affichage();

                //on récupère sa demande
                String msg = reader.readLine();

                //si le message est END, on ferme le thread, sinon on appelle la méthode correspondante
                if (msg.equals("END")){
                    break;
                } else{
                    switch(msg){
                        case "Moyenne":{
                            Moyenne();
                            break;
                        }
                        case "Proportion":{
                            Proportion();
                            break;
                        }
                        case "Persistance":{
                            Persistance();
                            break;
                        }
                    }
                }
            }
            //fermeture
            reader.close();
            writer.close();
            s.close();
            Serveur.FinClient();
            this.etat = "Déconnecté";
            Serveur.Affichage();
       }catch(IOException e){e.printStackTrace();}
    }

    /*
     * méthode pour l'affichage des clients
     */
    public ArrayList<String> getStr(){
        ArrayList<String> Str = new ArrayList<String>();
        Str.add("Client " + this.getName());
        Str.add(this.etat);
        return Str;
    }

    /*
     * méthode pour gérer la demande de moyenne
     */
    public void Moyenne(){
        try{
            //on récupère ce que veut l'utiisateur (TOTALE ou INTERVALLE)
            String commande = reader.readLine();

            if(commande.equals("TOTALE")){
                //si le client veut la moyenne totale, on lui envoie celle qu'on a calculée
                writer.println(Serveur.getMoyenneTotale());
                writer.flush();
            }
            if(commande.equals("INTERVALLE")){

                //on envoie le nombre maximal sotcké
                writer.println(Serveur.getNbStockees());

                //on récupère le premier nombre
                String aS = reader.readLine();

                //on fait de même avec le dernier chiffre de l'intervalle
                String bS = reader.readLine();

                //on transforme les deux résultats en int
                int a = Integer.parseInt(aS);
                int b = Integer.parseInt(bS);

                //calcul de la moyenne entre a et b
                double moy=MoyIntervalle(a, b);

                //on envoie le résultat
                writer.println("La moyenne de la persistance des nombres entre "+a+" et "+b+" est de "+moy);
                writer.flush();
            }
        }
        catch(IOException e){e.printStackTrace();}
    }

    /*
     * méthode pour gérer la demande de persistance d'un nombre
     */
    public void Persistance(){
        try{
            //on envoie le nombre maximal sotcké
            writer.println(Serveur.getNbStockees());

            //on récupère le nombre choisi
            int nb=Integer.parseInt(reader.readLine());

            //on détermine le nom du fichier de la hashtable du nombre
            File f = new File("Serveur.java");
            String filename = f.getAbsolutePath();
            filename = filename.replace("Serveur.java", "");
            filename = filename+"/Fichier/";
            int a = (int)(nb/100000);
            filename = filename + a + "Cm_" + (a + 1) + "Cm.ser";

            //on récupère la hashtable comportant ce nombre
            FileInputStream file = new FileInputStream(filename);
            ObjectInputStream in = new ObjectInputStream(file);
            @SuppressWarnings("unchecked") Hashtable<Integer, Integer> h = (Hashtable<Integer, Integer>) in.readObject();
            in.close();
            file.close();

            //on renvoie la persistance de ce nombre
            writer.println(h.get(nb));
            writer.flush();
        }
        catch(Exception e){e.printStackTrace();}
    }
    
    /*
     * méthode pour gérer la demande de pourcentage d'un ordre 
     */
    public void Proportion(){
        try{

            //on récupère le nombre choisi
            int nb=Integer.parseInt(reader.readLine());

            //on récupère le résultat et on le renvoie
            double resultat = Serveur.pourcentage(nb);
            writer.println(resultat);
            writer.flush();
        }
        catch(Exception e){e.printStackTrace();}
    }

    /*
     * méthode pour générer un nom de fichier en fonction de l'intervalle
     */
    public String GenerateurNom(int a, int b){
        a = a / 100000;
        b = (b + 1) / 100000;
        String str = "" + a + "Cm_" + b + "Cm.ser";
        return str;
    }

    /*
     * méthode pour récupérer la moyenne des ordres des nombres d'un intervalle
     */
    @SuppressWarnings("unchecked")
    public double MoyIntervalle(int a, int b){
        double moy = 0;
        Hashtable<Integer,Integer> h=null;
        for(int i = a; i <= b ; i++){
            if(i == a || i%100000 == 0){
                /*
                 *si c'est le premier nombre ou le premier nombre d'un nouveau fichier,
                 *on récupère la hashtable du fichier 
                 */
                File f = new File("Serveur.java");
                String filename = f.getAbsolutePath();
                filename = filename.replace("Serveur.java", "");
                filename = filename+"/Fichier/"+GenerateurNom(i, i + 99999);
                try{
                    FileInputStream file = new FileInputStream(filename);
                    ObjectInputStream in = new ObjectInputStream(file);
                    h=(Hashtable<Integer, Integer>) in.readObject();
                    in.close();
                    file.close();
                } catch(Exception e){e.printStackTrace();}
            }

            //on ajoute à la moyenne la valeur de la persistance de i
            moy += h.get(i);
        }

        //on renvoie la moyenne
        moy = moy / (double)(b - a + 1);
        return moy;
    }
}
